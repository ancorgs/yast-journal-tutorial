---
layout: default
---

<h2>Hello world</h2>

<h3>A basic client as a first step</h3>
<p>
Usually, the first step when creating an application with a graphical interface
is drawing some mockups for that interface. It can be done with any availabe
tool (including good old paper&amp;pencil), but when developing a YaST module
you will always have to take into account the ncurses interface. With that in
mind, maybe using <a href="https://github.com/libyui/libyui">libyui</a>
(the widget abstraction library used by YaST) to write the mockup is not a bad
idea.
</p>
<p>
As explained in &quot;YaST architecture&quot; at
<a href="http://yast.github.io/documentation.html">the official YaST
documentation page</a>, executing YaST means actually calling a YaST client.
So let's write a client that will draw our mockup.
</p>

<h3>Checkout the initial mockup</h3>
<p>
First of all, let's travel in time to the origin and checkout the initial commit
of the repository.
</p>
{% highlight bash %}
git checkout hello_world
{% endhighlight %}

<h3>Browsing the code</h3>
<p>
The repository now contains just a directory called &quot;src&quot; to mimic
the structure described in &quot;YaST code organization description&quot;
at <a href="http://yast.github.io/documentation.html">the documentation</a>.
You will find that directory in every YaST module and you will soon find why.
</p>
<p>
Inside that directory there are only two files: &quot;clients/mockup.rb&quot;
and &quot;lib/systemd_journal/mockup_dialog.rb&quot;. The first one is mainly
a Ruby script. Whatever code is there it will be executed right away when
calling the client. Several old YaST modules contain clients with the
functionality implemented inline. This is now considered harmfull since it makes
harder to use automatic test tools. The preferred approach is to encapsulate the
functionality in classes and have minimal clients that simply invoke the methods
on those classes. As you can see, our mockup client simply calls the method
&quot;run&quot; of a MockupDialog object.
</p>
{% highlight ruby %}
require "journalctl/mockup_dialog"
Journalctl::MockupDialog.new.run
{% endhighlight %}
<p>
All the interesting code for this first &quot;hello world&quot; is in
mockup_dialog.rb, starting with the first two lines.
</p>
{% highlight ruby %}
require "yast"
Yast.import "UI"
{% endhighlight %}

<h3>Running the code</h3>
<p>
You could be tempted to use rake run, but it will not work because there is no
Rakefile. Don't worry. Let's forget about the magic for now. And let's run the
mockup client manually.
</p>
{% highlight bash %}
Y2DIR=src/ /usr/sbin/yast2 mockup
{% endhighlight %}

<p>
The only possible interaction is closing. Let's also take a look to ~/.y2log.
Now. Let's take a look to how it looks in ncurses (press 'esc' to exit)
</p>

{% highlight bash %}
Y2DIR=src/ /usr/sbin/yast2 --ncurses mockup
{% endhighlight %}

<p>
You can see the debugging output again in  ~/.y2log
</p>

<h3>Rejoice!</h3>
<p>
Celebrate your first YaST module. Once you are done with celebration, proceed to <a
  href="step2.html">the second step</a>.
</p>
